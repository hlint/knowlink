import { uploadFileByUrl } from "@/app/actions";
import { saveFile } from "@/integrations/file-storage";
import aiDocSummary from "@/lib/ai-doc-summary";
import { callLlm } from "@/lib/llm/llm";
import parseFavicon from "@/lib/parse-favicon";
import { parseBasics } from "@/lib/parse-html";
import { parseMarkdown } from "@/lib/parse-html";
import { prisma } from "@/lib/prisma";
import { shortId } from "@/lib/string";
import { retry } from "@/lib/time";
import { createImageService } from "pollinationsai";
import { random } from "radashi";

export async function getFavicon(url: string) {
  let result = "";
  const icons = await parseFavicon(url);
  const icon = icons.at(-1)?.src || "";
  if (icon) {
    await uploadFileByUrl(icon)
      .then((file) => {
        result = file.url;
      })
      .catch(() => {
        console.warn("getFavicon error for icon:", icon);
      });
  }
  return result;
}

export async function generateIcon(info: string) {
  const description = await callLlm({
    dialog: [
      {
        role: "system",
        content: `You are a professional icon designer. Generate a prompt (description in English) for image generation based on the user's content. Avoid pure white or black background.`,
      },
      {
        role: "user",
        content: `Content: ${info}`,
      },
    ],
  });
  const imageService = createImageService();
  const imageBuffer = await imageService.generate(description, {
    model: "flux",
    width: 512,
    height: 512,
    private: true,
    safe: false,
    nologo: true,
    enhance: true,
    seed: random(0, 1000000),
  });
  const filename = `${shortId()}.jpg`;
  const file = new File([imageBuffer], filename, {
    type: "image/jpeg",
  });
  const fileSaved = await saveFile(file);
  return fileSaved.url;
}

export async function getContentFromHtml(html: string) {
  const data = {
    title: "",
    description: "",
    content: "",
  };
  const { title, description } = await parseBasics(html);
  const markdown = parseMarkdown(html);
  data.title = title;
  data.content = `\n> ${description}\n${markdown}\n`;
  let body = await aiDocSummary({
    doc: html,
  });
  if (body.startsWith("```")) {
    body = body.replace(/^```[\S]*/, "").replace(/```$/, "");
  }
  const parseBodyResults = /^\s*#\s*(.*?)\s*\n+([\s\S]*)$/.exec(body);
  if (parseBodyResults) {
    data.title = parseBodyResults[1];
    data.content = parseBodyResults[2];
  } else {
    console.warn(
      "Can not parse the body generated by aiDocSummary:",
      body.slice(0, 200),
    );
  }
  return data;
}

export async function getContentFromDoc(doc: string) {
  const data = {
    title: "",
    content: "",
  };
  let body = await aiDocSummary({
    doc,
  });
  if (body.startsWith("```")) {
    body = body.replace(/^```[\S]*/, "").replace(/```$/, "");
  }
  const parseBodyResults = /^\s*#\s*(.*?)\s*\n+([\s\S]*)$/.exec(body);
  if (parseBodyResults) {
    data.title = parseBodyResults[1];
    data.content = parseBodyResults[2];
  } else {
    console.warn(
      "Can not parse the body generated by aiDocSummary:",
      body.slice(0, 200),
    );
    const lines = body.split("\n");
    data.title = lines[0];
    data.content = lines.slice(1).join("\n");
  }
  return data;
}

// Classify the content into a subcategory
export async function classify(content: string) {
  const categories = await prisma.category.findMany({
    select: {
      id: true,
      name: true,
      Subcategory: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
  const subcategories = categories.flatMap((category) =>
    category.Subcategory.map((subcategory) => ({
      id: subcategory.id,
      name: `${category.name} / ${subcategory.name}`,
    })),
  );
  const getSubcategoryId = retry(async (content: string) => {
    const result = await callLlm({
      dialog: [
        {
          role: "system",
          content: `You are a helpful assistant that classifies content into categories.
Ignore the content format, focus on the main idea.
The categories are:${JSON.stringify(subcategories)}
Choose the most appropriate Subcategory for the content, output reason and the id in JSON format.
Try to match the content to the most suitable category. Only if absolutely no category fits, the id should be null.
No extra text, only the JSON object.

EXAMPLE 1:
{"reason": "The content is about the installation of Next.js, it should be classified into the category of Development", "id": "123"}

EXAMPLE 2:
{"reason": "The content is about the installation of Next.js, no relevant category found", "id": null}
`,
        },
        {
          role: "user",
          content: `Classify the following content: ${content}`,
        },
      ],
    });
    return JSON.parse(result) as { id: string | null };
  });
  const { id } = await getSubcategoryId(content);
  return id;
}

export async function recommendSubcategory(noteId: string) {
  const categories = await prisma.category.findMany({
    select: {
      id: true,
      name: true,
      Subcategory: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
  const subcategories = categories.flatMap((category) =>
    category.Subcategory.map((subcategory) => ({
      id: subcategory.id,
      name: `${category.name} / ${subcategory.name}`,
    })),
  );
  const note = await prisma.note.findUnique({
    where: { id: noteId },
    select: {
      title: true,
      content: true,
    },
  });
  const content = `# ${note?.title}\n\n${note?.content}`;
  const getSubcategories = retry(async (content: string) => {
    const result = await callLlm({
      dialog: [
        {
          role: "system",
          content: `You are a helpful assistant that classifies content into categories.
Ignore the content format, focus on the main idea.
The categories are:${JSON.stringify(subcategories)}
Choose the most appropriate Subcategories for the content, output reason and the ids in JSON format.

The output should follow the following rules:
- Try to match the content to the most suitable categories.
- No more than 3 categories.
- Only if absolutely no category fits, the ids should be empty array.
- No extra text, only the JSON object.

EXAMPLE 1:
{"reason": "The content is about the installation of Next.js, it should be classified into the category of Development", "ids": ["subcategoryId1", "subcategoryId2"]}

EXAMPLE 2:
{"reason": "The content is about the installation of Next.js, no relevant category found", "ids": []}
`,
        },
        {
          role: "user",
          content: `Classify the following content: ${content}`,
        },
      ],
    });
    return JSON.parse(result) as { ids: string[] };
  });
  const { ids } = await getSubcategories(content);
  return ids;
}
